// old code //

// Seperated the errors from the warnings and returns them as int
func parseErrAndWarn(str string) (int, int) {
	errVal := 0
	var errBuff bytes.Buffer
	errDone := false
	warnVal := 0
	warnTurn := false
	var warnBuff bytes.Buffer

	// str format -> xx Errors, yy warning(s)

	for i := 0; i < len(str); i++ {
		if str[i] != ' ' { // Not a space
			if !errDone {
				errBuff.WriteByte(str[i])
				continue
			} else if !warnTurn && str[i] == ',' { // Warnings
				warnTurn = true
				continue
			} else if warnTurn {
				warnBuff.WriteByte(str[i])
			}
		} else { // a space
			if !errDone {
				tmpErrVal, err := strconv.Atoi(errBuff.String())
				if err != nil {
					errVal = -1
				} else {
					errVal = tmpErrVal
				}
				errDone = true
			} else if warnTurn && len(warnBuff.String()) != 0 {
				tmpWarnVal, err := strconv.Atoi(warnBuff.String())
				if err != nil {
					warnVal = -1
				} else {
					warnVal = tmpWarnVal
				}
				return errVal, warnVal
			}
		}
	}
	return errVal, warnVal
}

// Gets section in HMTL return that contains the errors
func filterHTML(html string, singleHTML *HTMLVerify) string {

	atErrors := false
	atWarnings := false
	divs := 0
	totErrorsAndWarnings := ""

	scanner := bufio.NewScanner(strings.NewReader(html)) // reads html
	html = ""                                            // resets html to "" bc we dont need it anymore
	// Used to keep track on what index the warn and err is supposed to be writed to in the singleHTML object
	for scanner.Scan() {
		if strings.Contains(scanner.Text(), "<div id=\"result\">") {
			// At section where errors are
			atErrors = true
			//continue
		} else if strings.Contains(scanner.Text(), "<h3 id=\"preparse_warnings\">Notes and Potential Issues</h3>") {
			// At section where warnings are
			atWarnings = true
			continue
		}

		if atWarnings {
			// Notes and Potential Issues - Section in html response
			// Parse warning data here

			// Take entire row and filter out tags and unwanted text
			if strings.Contains(scanner.Text(), "<span class=\"msg\">") {

				// Cleanup string. Removed /span and /p from string
				trimmedStr := scanner.Text()[:len(scanner.Text())-11]

				// Goes thru string backwards
				// Looking for  "msg">  string
				for i := len(scanner.Text()) - 3; i > 0; i-- {
					if scanner.Text()[i] == '>' && scanner.Text()[i-1] == '"' && scanner.Text()[i-2] == 'g' && scanner.Text()[i-3] == 's' {
						trimmedStr = trimmedStr[i+1:]
						break
					}
				}

				singleHTML.StrictVerify.Warnings = append(singleHTML.StrictVerify.Warnings, trimmedStr)

				// Check before loop
				if strings.Contains(scanner.Text(), "</span>") {
					continue
				}
				panic("Warning did not have </span> at the end") // debug
				/*
					// Loop till closing span
					for scanner.Scan() {
						//singleHTML.Warnings[currentWarningIndex] += scanner.Text()
						if strings.Contains(scanner.Text(), "</span>") { // end
							break
						}
					}
					continue
				*/
			}

			// Detects end of warnings
			if strings.Contains(scanner.Text(), "<!-- End of \"warnings\". -->") {
				atWarnings = false
				continue
			}
			continue
		}

		if atErrors {
			// Parse error data here

			// Runs once for each error group type
			if strings.Contains(scanner.Text(), "<li class=\"grouped msg_err\">") {
				for scanner.Scan() {
					var trimmedStrLine string
					var trimmedStrTextFromHTML string
					if strings.Contains(scanner.Text(), "<span class=\"msg\">") {

						// <span class="msg"> something something error... </span>
						var trimmerStr string
						for i := len(scanner.Text()) - 1; i > 0; i-- {
							if scanner.Text()[i] == '<' && scanner.Text()[i+1] == '/' {
								trimmerStr = scanner.Text()[:i] // Removed end off error
							} else if scanner.Text()[i] == '>' && scanner.Text()[i-1] == '"' {
								trimmerStr = trimmerStr[i+1:]
							}
						}

						tmpHolder := ErrorGroup{
							ErrorType: trimmerStr,
						}

						// Looks for all errors
						for scanner.Scan() {
							if strings.Contains(scanner.Text(), "<li>") { // Inside a errors info
								//for scanner.Scan() {

								// clean scanner.Text()

								// rework this. Takes too much!
								scanner.Scan()
								trimmedStrLine = scanner.Text() // gets <em>
								scanner.Scan()
								trimmedStrLine += scanner.Text() // Gets <span>
								scanner.Scan()
								trimmedStrTextFromHTML = scanner.Text() // Gets <pre>
								scanner.Scan()

								errorStringsData := TheError{
									LineRow:      trimmedStrLine,
									TextFromHTML: trimmedStrTextFromHTML,
								}

								tmpHolder.ErrorStrings = append(tmpHolder.ErrorStrings, errorStringsData)
								/*
									if strings.Contains(scanner.Text(), "</li>") { // end of that errors info
										// Save the string here?
										break
									}
									// Logic here for finding the text and rows etc
									}
								*/
							}

							if strings.Contains(scanner.Text(), "</ul>") { // end no more errors for this type
								// Save data
								singleHTML.StrictVerify.Errors = append(singleHTML.StrictVerify.Errors, tmpHolder)
								break
							}
						}

						/*
							errorStringsData := TheError{
								LineRow:      trimmedStrLine,
								TextFromHTML: trimmedStrTextFromHTML,
							}

							tmp := ErrorGroup{
								ErrorType: trimmerStr,
							}

							tmp.ErrorStrings = append(tmp.ErrorStrings, errorStringsData)
						*/
						// Saves the data
						//singleHTML.StrictVerify.Errors = append(singleHTML.StrictVerify.Errors, tmp)
					}
				}

				// Iterate to end off li. Each error is in its own li inside a ul
			}

			// Checks for when error section is over
			if strings.Contains(scanner.Text(), "<div ") {
				divs++
			} else if strings.Contains(scanner.Text(), "</div>") {
				divs--
			}
			html += fmt.Sprintf("%s\n", scanner.Text())
			if divs == 0 {
				return totErrorsAndWarnings
			}
			continue
		}

		// This is done outside of warnings and errors //

		// Check for <br> elements

		// Gets total errors and warnings
		if strings.Contains(scanner.Text(), "warning(s)") {
			totErrorsAndWarnings = scanner.Text()
			cpy := totErrorsAndWarnings
			for i := 0; i < len(cpy); i++ {
				if strings.Compare(string(cpy[i]), " ") == 0 {
					totErrorsAndWarnings = totErrorsAndWarnings[1:] // Tar bort bokstaven innan på index 0 (substring)
				} else {
					break
				}
			}
		}
		continue
	}

	// XHTML 1.0 Strict verify is done
	singleHTML.StrictVerify.Verified = true

	return totErrorsAndWarnings

	/*
		ol
			li
				span
					img
				/span
				span	// has error group msg
					p
						a
					/p
					div class="ve
						p		// Onödigt
						/p
					/div
					ul
						li	// Alla induviduella fel
							em	/em
							span /spawn
						/li
						*kan finnas flera li här*
					/ul
			/li
		/ol
	*/
}
